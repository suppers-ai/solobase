//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// ExtensionInfo holds information about discovered extensions
type ExtensionInfo struct {
	Package    string
	Name       string
	ImportPath string
	StructName string
	InitFunc   string
}

const generatedFileTemplate = `// Code generated by generate-extensions.go. DO NOT EDIT.

package solobase

import (
{{if .}}	"fmt"
{{end}}	"github.com/suppers-ai/solobase/extensions/core"
{{range .}}	"{{.ImportPath}}"
{{end}})

// RegisterExtensions registers all discovered extensions
func RegisterExtensions(registry *core.ExtensionRegistry) error {
{{range .}}	// Register {{.Name}}
{{if eq .Name "cloudstorage"}}	if err := registry.Register({{.Package}}.{{.InitFunc}}(nil)); err != nil {
		return fmt.Errorf("failed to register {{.Name}} extension: %w", err)
	}
{{else}}	if err := registry.Register({{.Package}}.{{.InitFunc}}()); err != nil {
		return fmt.Errorf("failed to register {{.Name}} extension: %w", err)
	}
{{end}}{{end}}
	return nil
}

// GetExtensionList returns a list of all available extensions
func GetExtensionList() []string {
	return []string{
{{range .}}		"{{.Name}}",
{{end}}	}
}
`

func main() {
	log.Println("Discovering extensions...")

	// Find all extension directories
	extensionDirs := []string{
		"extensions/official",
		"extensions/community",
		"extensions/custom",
	}

	var extensions []ExtensionInfo

	for _, dir := range extensionDirs {
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			log.Printf("Directory %s does not exist, skipping", dir)
			continue
		}

		// Walk through extension directories
		err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			// Look for extension.go files
			if info.Name() == "extension.go" {
				ext, err := parseExtension(path)
				if err != nil {
					log.Printf("Failed to parse %s: %v", path, err)
					return nil
				}
				if ext != nil {
					extensions = append(extensions, *ext)
					log.Printf("Found extension: %s", ext.Name)
				}
			}

			return nil
		})

		if err != nil {
			log.Printf("Error walking directory %s: %v", dir, err)
		}
	}

	// Generate the registration file
	if err := generateRegistrationFile(extensions); err != nil {
		log.Fatalf("Failed to generate registration file: %v", err)
	}

	log.Printf("Successfully discovered %d extensions", len(extensions))
}

func parseExtension(filePath string) (*ExtensionInfo, error) {
	content, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, content, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	// Extract package name
	packageName := node.Name.Name

	// Look for struct that implements Extension interface
	var structName string
	var hasNewFunc bool

	for _, decl := range node.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			if d.Tok == token.TYPE {
				for _, spec := range d.Specs {
					if ts, ok := spec.(*ast.TypeSpec); ok {
						if _, ok := ts.Type.(*ast.StructType); ok {
							// Check if it ends with "Extension"
							if strings.HasSuffix(ts.Name.Name, "Extension") {
								structName = ts.Name.Name
							}
						}
					}
				}
			}
		case *ast.FuncDecl:
			// Look for New* function
			if d.Name != nil && strings.HasPrefix(d.Name.Name, "New") && strings.HasSuffix(d.Name.Name, "Extension") {
				hasNewFunc = true
			}
		}
	}

	if structName == "" || !hasNewFunc {
		return nil, nil // Not a valid extension file
	}

	// Build import path
	dir := filepath.Dir(filePath)
	importPath := fmt.Sprintf("github.com/suppers-ai/solobase/%s", filepath.ToSlash(dir))

	// Extract extension name from path
	parts := strings.Split(dir, string(filepath.Separator))
	extensionName := parts[len(parts)-1]

	return &ExtensionInfo{
		Package:    packageName,
		Name:       extensionName,
		ImportPath: importPath,
		StructName: structName,
		InitFunc:   fmt.Sprintf("New%s", structName),
	}, nil
}

func generateRegistrationFile(extensions []ExtensionInfo) error {
	tmpl, err := template.New("generated").Parse(generatedFileTemplate)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, extensions); err != nil {
		return err
	}

	// Format the generated code
	formatted := buf.Bytes()

	// Write to file in main package directory
	outputPath := "extensions_generated.go"
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return err
	}

	log.Printf("Generated %s", outputPath)
	return nil
}
