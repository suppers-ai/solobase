// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: logs.sql

package db

import (
	"context"
	"encoding/json"
)

const countLogs = `-- name: CountLogs :one
SELECT COUNT(*) FROM sys_logs
`

func (q *Queries) CountLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLogsByLevel = `-- name: CountLogsByLevel :one
SELECT COUNT(*) FROM sys_logs WHERE level = ?
`

func (q *Queries) CountLogsByLevel(ctx context.Context, level string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLogsByLevel, level)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRequestLogs = `-- name: CountRequestLogs :one
SELECT COUNT(*) FROM sys_request_logs
`

func (q *Queries) CountRequestLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRequestLogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRequestLogsByStatusCode = `-- name: CountRequestLogsByStatusCode :one
SELECT COUNT(*) FROM sys_request_logs WHERE status_code = ?
`

func (q *Queries) CountRequestLogsByStatusCode(ctx context.Context, statusCode int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRequestLogsByStatusCode, statusCode)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLog = `-- name: CreateLog :one

INSERT INTO sys_logs (id, level, message, fields, user_id, trace_id, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, level, message, fields, user_id, trace_id, created_at
`

type CreateLogParams struct {
	ID        string          `json:"id"`
	Level     string          `json:"level"`
	Message   string          `json:"message"`
	Fields    json.RawMessage `json:"fields"`
	UserID    *string         `json:"user_id"`
	TraceID   *string         `json:"trace_id"`
	CreatedAt string          `json:"created_at"`
}

// System Log queries
func (q *Queries) CreateLog(ctx context.Context, arg CreateLogParams) (SysLog, error) {
	row := q.db.QueryRowContext(ctx, createLog,
		arg.ID,
		arg.Level,
		arg.Message,
		arg.Fields,
		arg.UserID,
		arg.TraceID,
		arg.CreatedAt,
	)
	var i SysLog
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Message,
		&i.Fields,
		&i.UserID,
		&i.TraceID,
		&i.CreatedAt,
	)
	return i, err
}

const createRequestLog = `-- name: CreateRequestLog :one

INSERT INTO sys_request_logs (
    id, level, method, path, query, status_code, exec_time_ms,
    user_ip, user_agent, user_id, trace_id, error, request_body,
    response_body, headers, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, level, method, path, "query", status_code, exec_time_ms, user_ip, user_agent, user_id, trace_id, error, request_body, response_body, headers, created_at
`

type CreateRequestLogParams struct {
	ID           string  `json:"id"`
	Level        string  `json:"level"`
	Method       string  `json:"method"`
	Path         string  `json:"path"`
	Query        *string `json:"query"`
	StatusCode   int64   `json:"status_code"`
	ExecTimeMs   int64   `json:"exec_time_ms"`
	UserIp       string  `json:"user_ip"`
	UserAgent    *string `json:"user_agent"`
	UserID       *string `json:"user_id"`
	TraceID      *string `json:"trace_id"`
	Error        *string `json:"error"`
	RequestBody  *string `json:"request_body"`
	ResponseBody *string `json:"response_body"`
	Headers      *string `json:"headers"`
	CreatedAt    string  `json:"created_at"`
}

// Request Log queries
func (q *Queries) CreateRequestLog(ctx context.Context, arg CreateRequestLogParams) (SysRequestLog, error) {
	row := q.db.QueryRowContext(ctx, createRequestLog,
		arg.ID,
		arg.Level,
		arg.Method,
		arg.Path,
		arg.Query,
		arg.StatusCode,
		arg.ExecTimeMs,
		arg.UserIp,
		arg.UserAgent,
		arg.UserID,
		arg.TraceID,
		arg.Error,
		arg.RequestBody,
		arg.ResponseBody,
		arg.Headers,
		arg.CreatedAt,
	)
	var i SysRequestLog
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Method,
		&i.Path,
		&i.Query,
		&i.StatusCode,
		&i.ExecTimeMs,
		&i.UserIp,
		&i.UserAgent,
		&i.UserID,
		&i.TraceID,
		&i.Error,
		&i.RequestBody,
		&i.ResponseBody,
		&i.Headers,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLogsOlderThan = `-- name: DeleteLogsOlderThan :exec
DELETE FROM sys_logs WHERE created_at < ?
`

func (q *Queries) DeleteLogsOlderThan(ctx context.Context, createdAt string) error {
	_, err := q.db.ExecContext(ctx, deleteLogsOlderThan, createdAt)
	return err
}

const deleteRequestLogsOlderThan = `-- name: DeleteRequestLogsOlderThan :exec
DELETE FROM sys_request_logs WHERE created_at < ?
`

func (q *Queries) DeleteRequestLogsOlderThan(ctx context.Context, createdAt string) error {
	_, err := q.db.ExecContext(ctx, deleteRequestLogsOlderThan, createdAt)
	return err
}

const listErrorRequestLogs = `-- name: ListErrorRequestLogs :many
SELECT id, level, method, path, "query", status_code, exec_time_ms, user_ip, user_agent, user_id, trace_id, error, request_body, response_body, headers, created_at FROM sys_request_logs WHERE status_code >= 400 ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListErrorRequestLogsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListErrorRequestLogs(ctx context.Context, arg ListErrorRequestLogsParams) ([]SysRequestLog, error) {
	rows, err := q.db.QueryContext(ctx, listErrorRequestLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysRequestLog{}
	for rows.Next() {
		var i SysRequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Method,
			&i.Path,
			&i.Query,
			&i.StatusCode,
			&i.ExecTimeMs,
			&i.UserIp,
			&i.UserAgent,
			&i.UserID,
			&i.TraceID,
			&i.Error,
			&i.RequestBody,
			&i.ResponseBody,
			&i.Headers,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogs = `-- name: ListLogs :many
SELECT id, level, message, fields, user_id, trace_id, created_at FROM sys_logs ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListLogsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListLogs(ctx context.Context, arg ListLogsParams) ([]SysLog, error) {
	rows, err := q.db.QueryContext(ctx, listLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysLog{}
	for rows.Next() {
		var i SysLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Fields,
			&i.UserID,
			&i.TraceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByLevel = `-- name: ListLogsByLevel :many
SELECT id, level, message, fields, user_id, trace_id, created_at FROM sys_logs WHERE level = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListLogsByLevelParams struct {
	Level  string `json:"level"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListLogsByLevel(ctx context.Context, arg ListLogsByLevelParams) ([]SysLog, error) {
	rows, err := q.db.QueryContext(ctx, listLogsByLevel, arg.Level, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysLog{}
	for rows.Next() {
		var i SysLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Fields,
			&i.UserID,
			&i.TraceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByTraceID = `-- name: ListLogsByTraceID :many
SELECT id, level, message, fields, user_id, trace_id, created_at FROM sys_logs WHERE trace_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListLogsByTraceID(ctx context.Context, traceID *string) ([]SysLog, error) {
	rows, err := q.db.QueryContext(ctx, listLogsByTraceID, traceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysLog{}
	for rows.Next() {
		var i SysLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Fields,
			&i.UserID,
			&i.TraceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByUserID = `-- name: ListLogsByUserID :many
SELECT id, level, message, fields, user_id, trace_id, created_at FROM sys_logs WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListLogsByUserIDParams struct {
	UserID *string `json:"user_id"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
}

func (q *Queries) ListLogsByUserID(ctx context.Context, arg ListLogsByUserIDParams) ([]SysLog, error) {
	rows, err := q.db.QueryContext(ctx, listLogsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysLog{}
	for rows.Next() {
		var i SysLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Fields,
			&i.UserID,
			&i.TraceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestLogs = `-- name: ListRequestLogs :many
SELECT id, level, method, path, "query", status_code, exec_time_ms, user_ip, user_agent, user_id, trace_id, error, request_body, response_body, headers, created_at FROM sys_request_logs ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListRequestLogsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListRequestLogs(ctx context.Context, arg ListRequestLogsParams) ([]SysRequestLog, error) {
	rows, err := q.db.QueryContext(ctx, listRequestLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysRequestLog{}
	for rows.Next() {
		var i SysRequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Method,
			&i.Path,
			&i.Query,
			&i.StatusCode,
			&i.ExecTimeMs,
			&i.UserIp,
			&i.UserAgent,
			&i.UserID,
			&i.TraceID,
			&i.Error,
			&i.RequestBody,
			&i.ResponseBody,
			&i.Headers,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestLogsByMethod = `-- name: ListRequestLogsByMethod :many
SELECT id, level, method, path, "query", status_code, exec_time_ms, user_ip, user_agent, user_id, trace_id, error, request_body, response_body, headers, created_at FROM sys_request_logs WHERE method = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListRequestLogsByMethodParams struct {
	Method string `json:"method"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListRequestLogsByMethod(ctx context.Context, arg ListRequestLogsByMethodParams) ([]SysRequestLog, error) {
	rows, err := q.db.QueryContext(ctx, listRequestLogsByMethod, arg.Method, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysRequestLog{}
	for rows.Next() {
		var i SysRequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Method,
			&i.Path,
			&i.Query,
			&i.StatusCode,
			&i.ExecTimeMs,
			&i.UserIp,
			&i.UserAgent,
			&i.UserID,
			&i.TraceID,
			&i.Error,
			&i.RequestBody,
			&i.ResponseBody,
			&i.Headers,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestLogsByPath = `-- name: ListRequestLogsByPath :many
SELECT id, level, method, path, "query", status_code, exec_time_ms, user_ip, user_agent, user_id, trace_id, error, request_body, response_body, headers, created_at FROM sys_request_logs WHERE path LIKE ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListRequestLogsByPathParams struct {
	Path   string `json:"path"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListRequestLogsByPath(ctx context.Context, arg ListRequestLogsByPathParams) ([]SysRequestLog, error) {
	rows, err := q.db.QueryContext(ctx, listRequestLogsByPath, arg.Path, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysRequestLog{}
	for rows.Next() {
		var i SysRequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Method,
			&i.Path,
			&i.Query,
			&i.StatusCode,
			&i.ExecTimeMs,
			&i.UserIp,
			&i.UserAgent,
			&i.UserID,
			&i.TraceID,
			&i.Error,
			&i.RequestBody,
			&i.ResponseBody,
			&i.Headers,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestLogsByStatusCode = `-- name: ListRequestLogsByStatusCode :many
SELECT id, level, method, path, "query", status_code, exec_time_ms, user_ip, user_agent, user_id, trace_id, error, request_body, response_body, headers, created_at FROM sys_request_logs WHERE status_code = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListRequestLogsByStatusCodeParams struct {
	StatusCode int64 `json:"status_code"`
	Limit      int64 `json:"limit"`
	Offset     int64 `json:"offset"`
}

func (q *Queries) ListRequestLogsByStatusCode(ctx context.Context, arg ListRequestLogsByStatusCodeParams) ([]SysRequestLog, error) {
	rows, err := q.db.QueryContext(ctx, listRequestLogsByStatusCode, arg.StatusCode, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysRequestLog{}
	for rows.Next() {
		var i SysRequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Method,
			&i.Path,
			&i.Query,
			&i.StatusCode,
			&i.ExecTimeMs,
			&i.UserIp,
			&i.UserAgent,
			&i.UserID,
			&i.TraceID,
			&i.Error,
			&i.RequestBody,
			&i.ResponseBody,
			&i.Headers,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestLogsByUserID = `-- name: ListRequestLogsByUserID :many
SELECT id, level, method, path, "query", status_code, exec_time_ms, user_ip, user_agent, user_id, trace_id, error, request_body, response_body, headers, created_at FROM sys_request_logs WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListRequestLogsByUserIDParams struct {
	UserID *string `json:"user_id"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
}

func (q *Queries) ListRequestLogsByUserID(ctx context.Context, arg ListRequestLogsByUserIDParams) ([]SysRequestLog, error) {
	rows, err := q.db.QueryContext(ctx, listRequestLogsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SysRequestLog{}
	for rows.Next() {
		var i SysRequestLog
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Method,
			&i.Path,
			&i.Query,
			&i.StatusCode,
			&i.ExecTimeMs,
			&i.UserIp,
			&i.UserAgent,
			&i.UserID,
			&i.TraceID,
			&i.Error,
			&i.RequestBody,
			&i.ResponseBody,
			&i.Headers,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
