// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: storage.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/suppers-ai/solobase/internal/pkg/apptime"
)

const completeDownloadToken = `-- name: CompleteDownloadToken :exec
UPDATE storage_download_tokens SET completed = 1, callback_at = ? WHERE id = ?
`

type CompleteDownloadTokenParams struct {
	CallbackAt apptime.NullTime `json:"callback_at"`
	ID         string           `json:"id"`
}

func (q *Queries) CompleteDownloadToken(ctx context.Context, arg CompleteDownloadTokenParams) error {
	_, err := q.db.ExecContext(ctx, completeDownloadToken, arg.CallbackAt, arg.ID)
	return err
}

const completeUploadToken = `-- name: CompleteUploadToken :exec
UPDATE storage_upload_tokens SET completed = 1, object_id = ?, completed_at = ? WHERE id = ?
`

type CompleteUploadTokenParams struct {
	ObjectID    *string          `json:"object_id"`
	CompletedAt apptime.NullTime `json:"completed_at"`
	ID          string           `json:"id"`
}

func (q *Queries) CompleteUploadToken(ctx context.Context, arg CompleteUploadTokenParams) error {
	_, err := q.db.ExecContext(ctx, completeUploadToken, arg.ObjectID, arg.CompletedAt, arg.ID)
	return err
}

const countObjectsByBucket = `-- name: CountObjectsByBucket :one
SELECT COUNT(*) FROM storage_objects WHERE bucket_name = ?
`

func (q *Queries) CountObjectsByBucket(ctx context.Context, bucketName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countObjectsByBucket, bucketName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countObjectsByUser = `-- name: CountObjectsByUser :one
SELECT COUNT(*) FROM storage_objects WHERE user_id = ?
`

func (q *Queries) CountObjectsByUser(ctx context.Context, userID *string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countObjectsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBucket = `-- name: CreateBucket :one

INSERT INTO storage_buckets (id, name, public)
VALUES (?, ?, ?)
RETURNING id, name, public, created_at, updated_at
`

type CreateBucketParams struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Public *int64 `json:"public"`
}

// Storage Bucket queries
func (q *Queries) CreateBucket(ctx context.Context, arg CreateBucketParams) (StorageBucket, error) {
	row := q.db.QueryRowContext(ctx, createBucket, arg.ID, arg.Name, arg.Public)
	var i StorageBucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDownloadToken = `-- name: CreateDownloadToken :one

INSERT INTO storage_download_tokens (
    id, token, file_id, bucket, parent_folder_id, object_name,
    user_id, file_size, expires_at, created_at, client_ip
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, token, file_id, bucket, parent_folder_id, object_name, user_id, file_size, bytes_served, completed, expires_at, created_at, callback_at, client_ip
`

type CreateDownloadTokenParams struct {
	ID             string           `json:"id"`
	Token          string           `json:"token"`
	FileID         string           `json:"file_id"`
	Bucket         string           `json:"bucket"`
	ParentFolderID *string          `json:"parent_folder_id"`
	ObjectName     string           `json:"object_name"`
	UserID         *string          `json:"user_id"`
	FileSize       *int64           `json:"file_size"`
	ExpiresAt      apptime.NullTime `json:"expires_at"`
	CreatedAt      string           `json:"created_at"`
	ClientIp       *string          `json:"client_ip"`
}

// Download Token queries
func (q *Queries) CreateDownloadToken(ctx context.Context, arg CreateDownloadTokenParams) (StorageDownloadToken, error) {
	row := q.db.QueryRowContext(ctx, createDownloadToken,
		arg.ID,
		arg.Token,
		arg.FileID,
		arg.Bucket,
		arg.ParentFolderID,
		arg.ObjectName,
		arg.UserID,
		arg.FileSize,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.ClientIp,
	)
	var i StorageDownloadToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.FileID,
		&i.Bucket,
		&i.ParentFolderID,
		&i.ObjectName,
		&i.UserID,
		&i.FileSize,
		&i.BytesServed,
		&i.Completed,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CallbackAt,
		&i.ClientIp,
	)
	return i, err
}

const createObject = `-- name: CreateObject :one

INSERT INTO storage_objects (
    id, bucket_name, object_name, parent_folder_id, size, content_type,
    checksum, metadata, user_id, app_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, bucket_name, object_name, parent_folder_id, size, content_type, checksum, metadata, created_at, updated_at, last_viewed, user_id, app_id
`

type CreateObjectParams struct {
	ID             string          `json:"id"`
	BucketName     string          `json:"bucket_name"`
	ObjectName     string          `json:"object_name"`
	ParentFolderID *string         `json:"parent_folder_id"`
	Size           *int64          `json:"size"`
	ContentType    *string         `json:"content_type"`
	Checksum       *string         `json:"checksum"`
	Metadata       json.RawMessage `json:"metadata"`
	UserID         *string         `json:"user_id"`
	AppID          *string         `json:"app_id"`
}

// Storage Object queries
func (q *Queries) CreateObject(ctx context.Context, arg CreateObjectParams) (StorageObject, error) {
	row := q.db.QueryRowContext(ctx, createObject,
		arg.ID,
		arg.BucketName,
		arg.ObjectName,
		arg.ParentFolderID,
		arg.Size,
		arg.ContentType,
		arg.Checksum,
		arg.Metadata,
		arg.UserID,
		arg.AppID,
	)
	var i StorageObject
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.ObjectName,
		&i.ParentFolderID,
		&i.Size,
		&i.ContentType,
		&i.Checksum,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewed,
		&i.UserID,
		&i.AppID,
	)
	return i, err
}

const createUploadToken = `-- name: CreateUploadToken :one

INSERT INTO storage_upload_tokens (
    id, token, bucket, parent_folder_id, object_name, user_id,
    max_size, content_type, expires_at, created_at, client_ip
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, token, bucket, parent_folder_id, object_name, user_id, max_size, content_type, bytes_uploaded, completed, object_id, expires_at, created_at, completed_at, client_ip
`

type CreateUploadTokenParams struct {
	ID             string           `json:"id"`
	Token          string           `json:"token"`
	Bucket         string           `json:"bucket"`
	ParentFolderID *string          `json:"parent_folder_id"`
	ObjectName     string           `json:"object_name"`
	UserID         *string          `json:"user_id"`
	MaxSize        *int64           `json:"max_size"`
	ContentType    *string          `json:"content_type"`
	ExpiresAt      apptime.NullTime `json:"expires_at"`
	CreatedAt      string           `json:"created_at"`
	ClientIp       *string          `json:"client_ip"`
}

// Upload Token queries
func (q *Queries) CreateUploadToken(ctx context.Context, arg CreateUploadTokenParams) (StorageUploadToken, error) {
	row := q.db.QueryRowContext(ctx, createUploadToken,
		arg.ID,
		arg.Token,
		arg.Bucket,
		arg.ParentFolderID,
		arg.ObjectName,
		arg.UserID,
		arg.MaxSize,
		arg.ContentType,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.ClientIp,
	)
	var i StorageUploadToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.Bucket,
		&i.ParentFolderID,
		&i.ObjectName,
		&i.UserID,
		&i.MaxSize,
		&i.ContentType,
		&i.BytesUploaded,
		&i.Completed,
		&i.ObjectID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.ClientIp,
	)
	return i, err
}

const deleteBucket = `-- name: DeleteBucket :exec
DELETE FROM storage_buckets WHERE id = ?
`

func (q *Queries) DeleteBucket(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteBucket, id)
	return err
}

const deleteDownloadToken = `-- name: DeleteDownloadToken :exec
DELETE FROM storage_download_tokens WHERE id = ?
`

func (q *Queries) DeleteDownloadToken(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteDownloadToken, id)
	return err
}

const deleteExpiredDownloadTokens = `-- name: DeleteExpiredDownloadTokens :exec
DELETE FROM storage_download_tokens WHERE expires_at < ? AND completed = 0
`

func (q *Queries) DeleteExpiredDownloadTokens(ctx context.Context, expiresAt apptime.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredDownloadTokens, expiresAt)
	return err
}

const deleteExpiredUploadTokens = `-- name: DeleteExpiredUploadTokens :exec
DELETE FROM storage_upload_tokens WHERE expires_at < ? AND completed = 0
`

func (q *Queries) DeleteExpiredUploadTokens(ctx context.Context, expiresAt apptime.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredUploadTokens, expiresAt)
	return err
}

const deleteObject = `-- name: DeleteObject :exec
DELETE FROM storage_objects WHERE id = ?
`

func (q *Queries) DeleteObject(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteObject, id)
	return err
}

const deleteObjectsByBucket = `-- name: DeleteObjectsByBucket :exec
DELETE FROM storage_objects WHERE bucket_name = ?
`

func (q *Queries) DeleteObjectsByBucket(ctx context.Context, bucketName string) error {
	_, err := q.db.ExecContext(ctx, deleteObjectsByBucket, bucketName)
	return err
}

const deleteObjectsByParentFolder = `-- name: DeleteObjectsByParentFolder :exec
DELETE FROM storage_objects WHERE parent_folder_id = ?
`

func (q *Queries) DeleteObjectsByParentFolder(ctx context.Context, parentFolderID *string) error {
	_, err := q.db.ExecContext(ctx, deleteObjectsByParentFolder, parentFolderID)
	return err
}

const deleteUploadToken = `-- name: DeleteUploadToken :exec
DELETE FROM storage_upload_tokens WHERE id = ?
`

func (q *Queries) DeleteUploadToken(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUploadToken, id)
	return err
}

const getBucketByID = `-- name: GetBucketByID :one
SELECT id, name, public, created_at, updated_at FROM storage_buckets WHERE id = ? LIMIT 1
`

func (q *Queries) GetBucketByID(ctx context.Context, id string) (StorageBucket, error) {
	row := q.db.QueryRowContext(ctx, getBucketByID, id)
	var i StorageBucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBucketByName = `-- name: GetBucketByName :one
SELECT id, name, public, created_at, updated_at FROM storage_buckets WHERE name = ? LIMIT 1
`

func (q *Queries) GetBucketByName(ctx context.Context, name string) (StorageBucket, error) {
	row := q.db.QueryRowContext(ctx, getBucketByName, name)
	var i StorageBucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDownloadTokenByID = `-- name: GetDownloadTokenByID :one
SELECT id, token, file_id, bucket, parent_folder_id, object_name, user_id, file_size, bytes_served, completed, expires_at, created_at, callback_at, client_ip FROM storage_download_tokens WHERE id = ? LIMIT 1
`

func (q *Queries) GetDownloadTokenByID(ctx context.Context, id string) (StorageDownloadToken, error) {
	row := q.db.QueryRowContext(ctx, getDownloadTokenByID, id)
	var i StorageDownloadToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.FileID,
		&i.Bucket,
		&i.ParentFolderID,
		&i.ObjectName,
		&i.UserID,
		&i.FileSize,
		&i.BytesServed,
		&i.Completed,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CallbackAt,
		&i.ClientIp,
	)
	return i, err
}

const getDownloadTokenByToken = `-- name: GetDownloadTokenByToken :one
SELECT id, token, file_id, bucket, parent_folder_id, object_name, user_id, file_size, bytes_served, completed, expires_at, created_at, callback_at, client_ip FROM storage_download_tokens WHERE token = ? LIMIT 1
`

func (q *Queries) GetDownloadTokenByToken(ctx context.Context, token string) (StorageDownloadToken, error) {
	row := q.db.QueryRowContext(ctx, getDownloadTokenByToken, token)
	var i StorageDownloadToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.FileID,
		&i.Bucket,
		&i.ParentFolderID,
		&i.ObjectName,
		&i.UserID,
		&i.FileSize,
		&i.BytesServed,
		&i.Completed,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CallbackAt,
		&i.ClientIp,
	)
	return i, err
}

const getObjectByChecksum = `-- name: GetObjectByChecksum :one
SELECT id, bucket_name, object_name, parent_folder_id, size, content_type, checksum, metadata, created_at, updated_at, last_viewed, user_id, app_id FROM storage_objects WHERE checksum = ? LIMIT 1
`

func (q *Queries) GetObjectByChecksum(ctx context.Context, checksum *string) (StorageObject, error) {
	row := q.db.QueryRowContext(ctx, getObjectByChecksum, checksum)
	var i StorageObject
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.ObjectName,
		&i.ParentFolderID,
		&i.Size,
		&i.ContentType,
		&i.Checksum,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewed,
		&i.UserID,
		&i.AppID,
	)
	return i, err
}

const getObjectByID = `-- name: GetObjectByID :one
SELECT id, bucket_name, object_name, parent_folder_id, size, content_type, checksum, metadata, created_at, updated_at, last_viewed, user_id, app_id FROM storage_objects WHERE id = ? LIMIT 1
`

func (q *Queries) GetObjectByID(ctx context.Context, id string) (StorageObject, error) {
	row := q.db.QueryRowContext(ctx, getObjectByID, id)
	var i StorageObject
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.ObjectName,
		&i.ParentFolderID,
		&i.Size,
		&i.ContentType,
		&i.Checksum,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewed,
		&i.UserID,
		&i.AppID,
	)
	return i, err
}

const getObjectByPath = `-- name: GetObjectByPath :one
SELECT id, bucket_name, object_name, parent_folder_id, size, content_type, checksum, metadata, created_at, updated_at, last_viewed, user_id, app_id FROM storage_objects WHERE bucket_name = ? AND object_name = ? LIMIT 1
`

type GetObjectByPathParams struct {
	BucketName string `json:"bucket_name"`
	ObjectName string `json:"object_name"`
}

func (q *Queries) GetObjectByPath(ctx context.Context, arg GetObjectByPathParams) (StorageObject, error) {
	row := q.db.QueryRowContext(ctx, getObjectByPath, arg.BucketName, arg.ObjectName)
	var i StorageObject
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.ObjectName,
		&i.ParentFolderID,
		&i.Size,
		&i.ContentType,
		&i.Checksum,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewed,
		&i.UserID,
		&i.AppID,
	)
	return i, err
}

const getUploadTokenByID = `-- name: GetUploadTokenByID :one
SELECT id, token, bucket, parent_folder_id, object_name, user_id, max_size, content_type, bytes_uploaded, completed, object_id, expires_at, created_at, completed_at, client_ip FROM storage_upload_tokens WHERE id = ? LIMIT 1
`

func (q *Queries) GetUploadTokenByID(ctx context.Context, id string) (StorageUploadToken, error) {
	row := q.db.QueryRowContext(ctx, getUploadTokenByID, id)
	var i StorageUploadToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.Bucket,
		&i.ParentFolderID,
		&i.ObjectName,
		&i.UserID,
		&i.MaxSize,
		&i.ContentType,
		&i.BytesUploaded,
		&i.Completed,
		&i.ObjectID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.ClientIp,
	)
	return i, err
}

const getUploadTokenByToken = `-- name: GetUploadTokenByToken :one
SELECT id, token, bucket, parent_folder_id, object_name, user_id, max_size, content_type, bytes_uploaded, completed, object_id, expires_at, created_at, completed_at, client_ip FROM storage_upload_tokens WHERE token = ? LIMIT 1
`

func (q *Queries) GetUploadTokenByToken(ctx context.Context, token string) (StorageUploadToken, error) {
	row := q.db.QueryRowContext(ctx, getUploadTokenByToken, token)
	var i StorageUploadToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.Bucket,
		&i.ParentFolderID,
		&i.ObjectName,
		&i.UserID,
		&i.MaxSize,
		&i.ContentType,
		&i.BytesUploaded,
		&i.Completed,
		&i.ObjectID,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.ClientIp,
	)
	return i, err
}

const listBuckets = `-- name: ListBuckets :many
SELECT id, name, public, created_at, updated_at FROM storage_buckets ORDER BY name
`

func (q *Queries) ListBuckets(ctx context.Context) ([]StorageBucket, error) {
	rows, err := q.db.QueryContext(ctx, listBuckets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StorageBucket{}
	for rows.Next() {
		var i StorageBucket
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectsByBucket = `-- name: ListObjectsByBucket :many
SELECT id, bucket_name, object_name, parent_folder_id, size, content_type, checksum, metadata, created_at, updated_at, last_viewed, user_id, app_id FROM storage_objects WHERE bucket_name = ? ORDER BY object_name
`

func (q *Queries) ListObjectsByBucket(ctx context.Context, bucketName string) ([]StorageObject, error) {
	rows, err := q.db.QueryContext(ctx, listObjectsByBucket, bucketName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StorageObject{}
	for rows.Next() {
		var i StorageObject
		if err := rows.Scan(
			&i.ID,
			&i.BucketName,
			&i.ObjectName,
			&i.ParentFolderID,
			&i.Size,
			&i.ContentType,
			&i.Checksum,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastViewed,
			&i.UserID,
			&i.AppID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectsByParentFolder = `-- name: ListObjectsByParentFolder :many
SELECT id, bucket_name, object_name, parent_folder_id, size, content_type, checksum, metadata, created_at, updated_at, last_viewed, user_id, app_id FROM storage_objects WHERE parent_folder_id = ? ORDER BY object_name
`

func (q *Queries) ListObjectsByParentFolder(ctx context.Context, parentFolderID *string) ([]StorageObject, error) {
	rows, err := q.db.QueryContext(ctx, listObjectsByParentFolder, parentFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StorageObject{}
	for rows.Next() {
		var i StorageObject
		if err := rows.Scan(
			&i.ID,
			&i.BucketName,
			&i.ObjectName,
			&i.ParentFolderID,
			&i.Size,
			&i.ContentType,
			&i.Checksum,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastViewed,
			&i.UserID,
			&i.AppID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectsByUser = `-- name: ListObjectsByUser :many
SELECT id, bucket_name, object_name, parent_folder_id, size, content_type, checksum, metadata, created_at, updated_at, last_viewed, user_id, app_id FROM storage_objects WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListObjectsByUserParams struct {
	UserID *string `json:"user_id"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
}

func (q *Queries) ListObjectsByUser(ctx context.Context, arg ListObjectsByUserParams) ([]StorageObject, error) {
	rows, err := q.db.QueryContext(ctx, listObjectsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StorageObject{}
	for rows.Next() {
		var i StorageObject
		if err := rows.Scan(
			&i.ID,
			&i.BucketName,
			&i.ObjectName,
			&i.ParentFolderID,
			&i.Size,
			&i.ContentType,
			&i.Checksum,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastViewed,
			&i.UserID,
			&i.AppID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootObjectsByBucket = `-- name: ListRootObjectsByBucket :many
SELECT id, bucket_name, object_name, parent_folder_id, size, content_type, checksum, metadata, created_at, updated_at, last_viewed, user_id, app_id FROM storage_objects WHERE bucket_name = ? AND parent_folder_id IS NULL ORDER BY object_name
`

func (q *Queries) ListRootObjectsByBucket(ctx context.Context, bucketName string) ([]StorageObject, error) {
	rows, err := q.db.QueryContext(ctx, listRootObjectsByBucket, bucketName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StorageObject{}
	for rows.Next() {
		var i StorageObject
		if err := rows.Scan(
			&i.ID,
			&i.BucketName,
			&i.ObjectName,
			&i.ParentFolderID,
			&i.Size,
			&i.ContentType,
			&i.Checksum,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastViewed,
			&i.UserID,
			&i.AppID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumSizeByBucket = `-- name: SumSizeByBucket :one
SELECT COALESCE(SUM(size), 0) FROM storage_objects WHERE bucket_name = ?
`

func (q *Queries) SumSizeByBucket(ctx context.Context, bucketName string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, sumSizeByBucket, bucketName)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const sumSizeByUser = `-- name: SumSizeByUser :one
SELECT COALESCE(SUM(size), 0) FROM storage_objects WHERE user_id = ?
`

func (q *Queries) SumSizeByUser(ctx context.Context, userID *string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, sumSizeByUser, userID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const updateBucket = `-- name: UpdateBucket :exec
UPDATE storage_buckets SET name = ?, public = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateBucketParams struct {
	Name   string `json:"name"`
	Public *int64 `json:"public"`
	ID     string `json:"id"`
}

func (q *Queries) UpdateBucket(ctx context.Context, arg UpdateBucketParams) error {
	_, err := q.db.ExecContext(ctx, updateBucket, arg.Name, arg.Public, arg.ID)
	return err
}

const updateDownloadTokenProgress = `-- name: UpdateDownloadTokenProgress :exec
UPDATE storage_download_tokens SET bytes_served = ? WHERE id = ?
`

type UpdateDownloadTokenProgressParams struct {
	BytesServed *int64 `json:"bytes_served"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateDownloadTokenProgress(ctx context.Context, arg UpdateDownloadTokenProgressParams) error {
	_, err := q.db.ExecContext(ctx, updateDownloadTokenProgress, arg.BytesServed, arg.ID)
	return err
}

const updateObject = `-- name: UpdateObject :exec
UPDATE storage_objects SET
    object_name = ?,
    parent_folder_id = ?,
    size = ?,
    content_type = ?,
    checksum = ?,
    metadata = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateObjectParams struct {
	ObjectName     string          `json:"object_name"`
	ParentFolderID *string         `json:"parent_folder_id"`
	Size           *int64          `json:"size"`
	ContentType    *string         `json:"content_type"`
	Checksum       *string         `json:"checksum"`
	Metadata       json.RawMessage `json:"metadata"`
	ID             string          `json:"id"`
}

func (q *Queries) UpdateObject(ctx context.Context, arg UpdateObjectParams) error {
	_, err := q.db.ExecContext(ctx, updateObject,
		arg.ObjectName,
		arg.ParentFolderID,
		arg.Size,
		arg.ContentType,
		arg.Checksum,
		arg.Metadata,
		arg.ID,
	)
	return err
}

const updateObjectLastViewed = `-- name: UpdateObjectLastViewed :exec
UPDATE storage_objects SET last_viewed = ? WHERE id = ?
`

type UpdateObjectLastViewedParams struct {
	LastViewed apptime.NullTime `json:"last_viewed"`
	ID         string           `json:"id"`
}

func (q *Queries) UpdateObjectLastViewed(ctx context.Context, arg UpdateObjectLastViewedParams) error {
	_, err := q.db.ExecContext(ctx, updateObjectLastViewed, arg.LastViewed, arg.ID)
	return err
}

const updateUploadTokenProgress = `-- name: UpdateUploadTokenProgress :exec
UPDATE storage_upload_tokens SET bytes_uploaded = ? WHERE id = ?
`

type UpdateUploadTokenProgressParams struct {
	BytesUploaded *int64 `json:"bytes_uploaded"`
	ID            string `json:"id"`
}

func (q *Queries) UpdateUploadTokenProgress(ctx context.Context, arg UpdateUploadTokenProgressParams) error {
	_, err := q.db.ExecContext(ctx, updateUploadTokenProgress, arg.BytesUploaded, arg.ID)
	return err
}
