// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: iam.sql

package db

import (
	"context"

	"github.com/suppers-ai/solobase/internal/pkg/apptime"
)

const countAuditLogs = `-- name: CountAuditLogs :one
SELECT COUNT(*) FROM iam_audit_logs
`

func (q *Queries) CountAuditLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAuditLogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsByUserID = `-- name: CountAuditLogsByUserID :one
SELECT COUNT(*) FROM iam_audit_logs WHERE user_id = ?
`

func (q *Queries) CountAuditLogsByUserID(ctx context.Context, userID *string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAuditLogsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :exec

INSERT INTO iam_audit_logs (id, user_id, action, resource, result, reason, ip_address, user_agent, metadata)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateAuditLogParams struct {
	ID        string  `json:"id"`
	UserID    *string `json:"user_id"`
	Action    *string `json:"action"`
	Resource  *string `json:"resource"`
	Result    *string `json:"result"`
	Reason    *string `json:"reason"`
	IpAddress *string `json:"ip_address"`
	UserAgent *string `json:"user_agent"`
	Metadata  *string `json:"metadata"`
}

// Audit Log queries
func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) error {
	_, err := q.db.ExecContext(ctx, createAuditLog,
		arg.ID,
		arg.UserID,
		arg.Action,
		arg.Resource,
		arg.Result,
		arg.Reason,
		arg.IpAddress,
		arg.UserAgent,
		arg.Metadata,
	)
	return err
}

const createPolicy = `-- name: CreatePolicy :exec

INSERT INTO iam_policies (id, ptype, v0, v1, v2, v3, v4, v5)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreatePolicyParams struct {
	ID    string  `json:"id"`
	Ptype string  `json:"ptype"`
	V0    *string `json:"v0"`
	V1    *string `json:"v1"`
	V2    *string `json:"v2"`
	V3    *string `json:"v3"`
	V4    *string `json:"v4"`
	V5    *string `json:"v5"`
}

// Policy queries
func (q *Queries) CreatePolicy(ctx context.Context, arg CreatePolicyParams) error {
	_, err := q.db.ExecContext(ctx, createPolicy,
		arg.ID,
		arg.Ptype,
		arg.V0,
		arg.V1,
		arg.V2,
		arg.V3,
		arg.V4,
		arg.V5,
	)
	return err
}

const createRole = `-- name: CreateRole :exec

INSERT INTO iam_roles (id, name, display_name, description, type, metadata)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateRoleParams struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	DisplayName *string `json:"display_name"`
	Description *string `json:"description"`
	Type        *string `json:"type"`
	Metadata    *string `json:"metadata"`
}

// Role queries
func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) error {
	_, err := q.db.ExecContext(ctx, createRole,
		arg.ID,
		arg.Name,
		arg.DisplayName,
		arg.Description,
		arg.Type,
		arg.Metadata,
	)
	return err
}

const createUserRole = `-- name: CreateUserRole :exec

INSERT INTO iam_user_roles (id, user_id, role_id, granted_by, expires_at)
VALUES (?, ?, ?, ?, ?)
`

type CreateUserRoleParams struct {
	ID        string           `json:"id"`
	UserID    string           `json:"user_id"`
	RoleID    string           `json:"role_id"`
	GrantedBy *string          `json:"granted_by"`
	ExpiresAt apptime.NullTime `json:"expires_at"`
}

// User Role queries
func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, createUserRole,
		arg.ID,
		arg.UserID,
		arg.RoleID,
		arg.GrantedBy,
		arg.ExpiresAt,
	)
	return err
}

const deleteAuditLogsOlderThan = `-- name: DeleteAuditLogsOlderThan :exec
DELETE FROM iam_audit_logs WHERE created_at < ?
`

func (q *Queries) DeleteAuditLogsOlderThan(ctx context.Context, createdAt string) error {
	_, err := q.db.ExecContext(ctx, deleteAuditLogsOlderThan, createdAt)
	return err
}

const deleteExpiredUserRoles = `-- name: DeleteExpiredUserRoles :exec
DELETE FROM iam_user_roles WHERE expires_at IS NOT NULL AND expires_at < ?
`

func (q *Queries) DeleteExpiredUserRoles(ctx context.Context, expiresAt apptime.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredUserRoles, expiresAt)
	return err
}

const deleteGroupingPoliciesByUser = `-- name: DeleteGroupingPoliciesByUser :exec
DELETE FROM iam_policies WHERE ptype = 'g' AND v0 = ?
`

func (q *Queries) DeleteGroupingPoliciesByUser(ctx context.Context, v0 *string) error {
	_, err := q.db.ExecContext(ctx, deleteGroupingPoliciesByUser, v0)
	return err
}

const deletePoliciesBySubject = `-- name: DeletePoliciesBySubject :exec
DELETE FROM iam_policies WHERE ptype = 'p' AND v0 = ?
`

func (q *Queries) DeletePoliciesBySubject(ctx context.Context, v0 *string) error {
	_, err := q.db.ExecContext(ctx, deletePoliciesBySubject, v0)
	return err
}

const deletePolicy = `-- name: DeletePolicy :exec
DELETE FROM iam_policies WHERE id = ?
`

func (q *Queries) DeletePolicy(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePolicy, id)
	return err
}

const deletePolicyByValues = `-- name: DeletePolicyByValues :exec
DELETE FROM iam_policies WHERE ptype = ? AND v0 = ? AND v1 = ? AND v2 = ? AND v3 = ?
`

type DeletePolicyByValuesParams struct {
	Ptype string  `json:"ptype"`
	V0    *string `json:"v0"`
	V1    *string `json:"v1"`
	V2    *string `json:"v2"`
	V3    *string `json:"v3"`
}

func (q *Queries) DeletePolicyByValues(ctx context.Context, arg DeletePolicyByValuesParams) error {
	_, err := q.db.ExecContext(ctx, deletePolicyByValues,
		arg.Ptype,
		arg.V0,
		arg.V1,
		arg.V2,
		arg.V3,
	)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM iam_roles WHERE id = ?
`

func (q *Queries) DeleteRole(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteRole, id)
	return err
}

const deleteUserRole = `-- name: DeleteUserRole :exec
DELETE FROM iam_user_roles WHERE user_id = ? AND role_id = ?
`

type DeleteUserRoleParams struct {
	UserID string `json:"user_id"`
	RoleID string `json:"role_id"`
}

func (q *Queries) DeleteUserRole(ctx context.Context, arg DeleteUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserRole, arg.UserID, arg.RoleID)
	return err
}

const deleteUserRolesByRoleID = `-- name: DeleteUserRolesByRoleID :exec
DELETE FROM iam_user_roles WHERE role_id = ?
`

func (q *Queries) DeleteUserRolesByRoleID(ctx context.Context, roleID string) error {
	_, err := q.db.ExecContext(ctx, deleteUserRolesByRoleID, roleID)
	return err
}

const deleteUserRolesByUserID = `-- name: DeleteUserRolesByUserID :exec
DELETE FROM iam_user_roles WHERE user_id = ?
`

func (q *Queries) DeleteUserRolesByUserID(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteUserRolesByUserID, userID)
	return err
}

const getPolicy = `-- name: GetPolicy :one
SELECT id, ptype, v0, v1, v2, v3, v4, v5, created_at FROM iam_policies WHERE ptype = ? AND v0 = ? AND v1 = ? AND v2 = ? AND v3 = ? LIMIT 1
`

type GetPolicyParams struct {
	Ptype string  `json:"ptype"`
	V0    *string `json:"v0"`
	V1    *string `json:"v1"`
	V2    *string `json:"v2"`
	V3    *string `json:"v3"`
}

func (q *Queries) GetPolicy(ctx context.Context, arg GetPolicyParams) (IamPolicy, error) {
	row := q.db.QueryRowContext(ctx, getPolicy,
		arg.Ptype,
		arg.V0,
		arg.V1,
		arg.V2,
		arg.V3,
	)
	var i IamPolicy
	err := row.Scan(
		&i.ID,
		&i.Ptype,
		&i.V0,
		&i.V1,
		&i.V2,
		&i.V3,
		&i.V4,
		&i.V5,
		&i.CreatedAt,
	)
	return i, err
}

const getPolicyByID = `-- name: GetPolicyByID :one
SELECT id, ptype, v0, v1, v2, v3, v4, v5, created_at FROM iam_policies WHERE id = ? LIMIT 1
`

func (q *Queries) GetPolicyByID(ctx context.Context, id string) (IamPolicy, error) {
	row := q.db.QueryRowContext(ctx, getPolicyByID, id)
	var i IamPolicy
	err := row.Scan(
		&i.ID,
		&i.Ptype,
		&i.V0,
		&i.V1,
		&i.V2,
		&i.V3,
		&i.V4,
		&i.V5,
		&i.CreatedAt,
	)
	return i, err
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, name, display_name, description, type, metadata, created_at, updated_at FROM iam_roles WHERE id = ? LIMIT 1
`

func (q *Queries) GetRoleByID(ctx context.Context, id string) (IamRole, error) {
	row := q.db.QueryRowContext(ctx, getRoleByID, id)
	var i IamRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Type,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, name, display_name, description, type, metadata, created_at, updated_at FROM iam_roles WHERE name = ? LIMIT 1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (IamRole, error) {
	row := q.db.QueryRowContext(ctx, getRoleByName, name)
	var i IamRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Type,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRole = `-- name: GetUserRole :one
SELECT id, user_id, role_id, granted_by, granted_at, expires_at FROM iam_user_roles WHERE user_id = ? AND role_id = ? LIMIT 1
`

type GetUserRoleParams struct {
	UserID string `json:"user_id"`
	RoleID string `json:"role_id"`
}

func (q *Queries) GetUserRole(ctx context.Context, arg GetUserRoleParams) (IamUserRole, error) {
	row := q.db.QueryRowContext(ctx, getUserRole, arg.UserID, arg.RoleID)
	var i IamUserRole
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoleID,
		&i.GrantedBy,
		&i.GrantedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, user_id, "action", resource, result, reason, ip_address, user_agent, metadata, created_at FROM iam_audit_logs ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListAuditLogsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]IamAuditLog, error) {
	rows, err := q.db.QueryContext(ctx, listAuditLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamAuditLog{}
	for rows.Next() {
		var i IamAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Resource,
			&i.Result,
			&i.Reason,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByAction = `-- name: ListAuditLogsByAction :many
SELECT id, user_id, "action", resource, result, reason, ip_address, user_agent, metadata, created_at FROM iam_audit_logs WHERE action = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListAuditLogsByActionParams struct {
	Action *string `json:"action"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
}

func (q *Queries) ListAuditLogsByAction(ctx context.Context, arg ListAuditLogsByActionParams) ([]IamAuditLog, error) {
	rows, err := q.db.QueryContext(ctx, listAuditLogsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamAuditLog{}
	for rows.Next() {
		var i IamAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Resource,
			&i.Result,
			&i.Reason,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByUserID = `-- name: ListAuditLogsByUserID :many
SELECT id, user_id, "action", resource, result, reason, ip_address, user_agent, metadata, created_at FROM iam_audit_logs WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListAuditLogsByUserIDParams struct {
	UserID *string `json:"user_id"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
}

func (q *Queries) ListAuditLogsByUserID(ctx context.Context, arg ListAuditLogsByUserIDParams) ([]IamAuditLog, error) {
	rows, err := q.db.QueryContext(ctx, listAuditLogsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamAuditLog{}
	for rows.Next() {
		var i IamAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Resource,
			&i.Result,
			&i.Reason,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupingPolicies = `-- name: ListGroupingPolicies :many
SELECT id, ptype, v0, v1, v2, v3, v4, v5, created_at FROM iam_policies WHERE ptype = 'g' ORDER BY created_at
`

func (q *Queries) ListGroupingPolicies(ctx context.Context) ([]IamPolicy, error) {
	rows, err := q.db.QueryContext(ctx, listGroupingPolicies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamPolicy{}
	for rows.Next() {
		var i IamPolicy
		if err := rows.Scan(
			&i.ID,
			&i.Ptype,
			&i.V0,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupingPoliciesByUser = `-- name: ListGroupingPoliciesByUser :many
SELECT id, ptype, v0, v1, v2, v3, v4, v5, created_at FROM iam_policies WHERE ptype = 'g' AND v0 = ? ORDER BY created_at
`

func (q *Queries) ListGroupingPoliciesByUser(ctx context.Context, v0 *string) ([]IamPolicy, error) {
	rows, err := q.db.QueryContext(ctx, listGroupingPoliciesByUser, v0)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamPolicy{}
	for rows.Next() {
		var i IamPolicy
		if err := rows.Scan(
			&i.ID,
			&i.Ptype,
			&i.V0,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPolicies = `-- name: ListPolicies :many
SELECT id, ptype, v0, v1, v2, v3, v4, v5, created_at FROM iam_policies ORDER BY created_at
`

func (q *Queries) ListPolicies(ctx context.Context) ([]IamPolicy, error) {
	rows, err := q.db.QueryContext(ctx, listPolicies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamPolicy{}
	for rows.Next() {
		var i IamPolicy
		if err := rows.Scan(
			&i.ID,
			&i.Ptype,
			&i.V0,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPoliciesBySubject = `-- name: ListPoliciesBySubject :many
SELECT id, ptype, v0, v1, v2, v3, v4, v5, created_at FROM iam_policies WHERE ptype = 'p' AND v0 = ? ORDER BY created_at
`

func (q *Queries) ListPoliciesBySubject(ctx context.Context, v0 *string) ([]IamPolicy, error) {
	rows, err := q.db.QueryContext(ctx, listPoliciesBySubject, v0)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamPolicy{}
	for rows.Next() {
		var i IamPolicy
		if err := rows.Scan(
			&i.ID,
			&i.Ptype,
			&i.V0,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPoliciesByType = `-- name: ListPoliciesByType :many
SELECT id, ptype, v0, v1, v2, v3, v4, v5, created_at FROM iam_policies WHERE ptype = ? ORDER BY created_at
`

func (q *Queries) ListPoliciesByType(ctx context.Context, ptype string) ([]IamPolicy, error) {
	rows, err := q.db.QueryContext(ctx, listPoliciesByType, ptype)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamPolicy{}
	for rows.Next() {
		var i IamPolicy
		if err := rows.Scan(
			&i.ID,
			&i.Ptype,
			&i.V0,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, name, display_name, description, type, metadata, created_at, updated_at FROM iam_roles ORDER BY name
`

func (q *Queries) ListRoles(ctx context.Context) ([]IamRole, error) {
	rows, err := q.db.QueryContext(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamRole{}
	for rows.Next() {
		var i IamRole
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Type,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolesByType = `-- name: ListRolesByType :many
SELECT id, name, display_name, description, type, metadata, created_at, updated_at FROM iam_roles WHERE type = ? ORDER BY name
`

func (q *Queries) ListRolesByType(ctx context.Context, type_ *string) ([]IamRole, error) {
	rows, err := q.db.QueryContext(ctx, listRolesByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamRole{}
	for rows.Next() {
		var i IamRole
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Type,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserIDsWithRole = `-- name: ListUserIDsWithRole :many
SELECT user_id FROM iam_user_roles WHERE role_id = ?
`

func (q *Queries) ListUserIDsWithRole(ctx context.Context, roleID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listUserIDsWithRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRolesByRoleID = `-- name: ListUserRolesByRoleID :many
SELECT id, user_id, role_id, granted_by, granted_at, expires_at FROM iam_user_roles WHERE role_id = ? ORDER BY granted_at DESC
`

func (q *Queries) ListUserRolesByRoleID(ctx context.Context, roleID string) ([]IamUserRole, error) {
	rows, err := q.db.QueryContext(ctx, listUserRolesByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IamUserRole{}
	for rows.Next() {
		var i IamUserRole
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.GrantedBy,
			&i.GrantedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRolesByUserID = `-- name: ListUserRolesByUserID :many
SELECT ur.id, ur.user_id, ur.role_id, ur.granted_by, ur.granted_at, ur.expires_at, r.name as role_name, r.display_name as role_display_name
FROM iam_user_roles ur
JOIN iam_roles r ON ur.role_id = r.id
WHERE ur.user_id = ?
ORDER BY ur.granted_at DESC
`

type ListUserRolesByUserIDRow struct {
	ID              string           `json:"id"`
	UserID          string           `json:"user_id"`
	RoleID          string           `json:"role_id"`
	GrantedBy       *string          `json:"granted_by"`
	GrantedAt       apptime.Time     `json:"granted_at"`
	ExpiresAt       apptime.NullTime `json:"expires_at"`
	RoleName        string           `json:"role_name"`
	RoleDisplayName *string          `json:"role_display_name"`
}

func (q *Queries) ListUserRolesByUserID(ctx context.Context, userID string) ([]ListUserRolesByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserRolesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserRolesByUserIDRow{}
	for rows.Next() {
		var i ListUserRolesByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.GrantedBy,
			&i.GrantedAt,
			&i.ExpiresAt,
			&i.RoleName,
			&i.RoleDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRole = `-- name: UpdateRole :exec
UPDATE iam_roles SET
    name = ?,
    display_name = ?,
    description = ?,
    type = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateRoleParams struct {
	Name        string  `json:"name"`
	DisplayName *string `json:"display_name"`
	Description *string `json:"description"`
	Type        *string `json:"type"`
	Metadata    *string `json:"metadata"`
	UpdatedAt   string  `json:"updated_at"`
	ID          string  `json:"id"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateRole,
		arg.Name,
		arg.DisplayName,
		arg.Description,
		arg.Type,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
