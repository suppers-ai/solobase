// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/suppers-ai/solobase/internal/pkg/apptime"
)

const clearUserRecoverToken = `-- name: ClearUserRecoverToken :exec
UPDATE auth_users SET
    recover_token = NULL,
    recover_selector = NULL,
    recover_token_exp = NULL,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type ClearUserRecoverTokenParams struct {
	UpdatedAt string `json:"updated_at"`
	ID        string `json:"id"`
}

func (q *Queries) ClearUserRecoverToken(ctx context.Context, arg ClearUserRecoverTokenParams) error {
	_, err := q.db.ExecContext(ctx, clearUserRecoverToken, arg.UpdatedAt, arg.ID)
	return err
}

const clearUserTOTP = `-- name: ClearUserTOTP :exec
UPDATE auth_users SET
    totp_secret = NULL,
    totp_secret_backup = NULL,
    recovery_codes = NULL,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type ClearUserTOTPParams struct {
	UpdatedAt string `json:"updated_at"`
	ID        string `json:"id"`
}

func (q *Queries) ClearUserTOTP(ctx context.Context, arg ClearUserTOTPParams) error {
	_, err := q.db.ExecContext(ctx, clearUserTOTP, arg.UpdatedAt, arg.ID)
	return err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM auth_users WHERE deleted_at IS NULL
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIKey = `-- name: CreateAPIKey :one

INSERT INTO api_keys (
    id, user_id, name, key_prefix, key_hash, scopes, expires_at, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, name, key_prefix, key_hash, scopes, expires_at, last_used_at, last_used_ip, revoked_at, created_at, updated_at
`

type CreateAPIKeyParams struct {
	ID        string           `json:"id"`
	UserID    string           `json:"user_id"`
	Name      string           `json:"name"`
	KeyPrefix string           `json:"key_prefix"`
	KeyHash   string           `json:"key_hash"`
	Scopes    json.RawMessage  `json:"scopes"`
	ExpiresAt apptime.NullTime `json:"expires_at"`
	CreatedAt string           `json:"created_at"`
	UpdatedAt string           `json:"updated_at"`
}

// API Key queries
func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, createAPIKey,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.KeyPrefix,
		arg.KeyHash,
		arg.Scopes,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyPrefix,
		&i.KeyHash,
		&i.Scopes,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createToken = `-- name: CreateToken :one

INSERT INTO auth_tokens (
    id, user_id, token_hash, token, type, family_id, provider, provider_uid,
    access_token, oauth_expiry, expires_at, device_info, ip_address, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, token_hash, token, type, family_id, provider, provider_uid, access_token, oauth_expiry, expires_at, used_at, revoked_at, created_at, device_info, ip_address
`

type CreateTokenParams struct {
	ID          string           `json:"id"`
	UserID      string           `json:"user_id"`
	TokenHash   *string          `json:"token_hash"`
	Token       *string          `json:"token"`
	Type        string           `json:"type"`
	FamilyID    *string          `json:"family_id"`
	Provider    *string          `json:"provider"`
	ProviderUid *string          `json:"provider_uid"`
	AccessToken *string          `json:"access_token"`
	OauthExpiry apptime.NullTime `json:"oauth_expiry"`
	ExpiresAt   apptime.NullTime `json:"expires_at"`
	DeviceInfo  *string          `json:"device_info"`
	IpAddress   *string          `json:"ip_address"`
	CreatedAt   string           `json:"created_at"`
}

// Token queries
func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, createToken,
		arg.ID,
		arg.UserID,
		arg.TokenHash,
		arg.Token,
		arg.Type,
		arg.FamilyID,
		arg.Provider,
		arg.ProviderUid,
		arg.AccessToken,
		arg.OauthExpiry,
		arg.ExpiresAt,
		arg.DeviceInfo,
		arg.IpAddress,
		arg.CreatedAt,
	)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Token,
		&i.Type,
		&i.FamilyID,
		&i.Provider,
		&i.ProviderUid,
		&i.AccessToken,
		&i.OauthExpiry,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.DeviceInfo,
		&i.IpAddress,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO auth_users (
    id, email, password, username, confirmed, first_name, last_name,
    display_name, phone, location, metadata, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, email, password, username, confirmed, first_name, last_name, display_name, phone, location, confirm_token, confirm_selector, recover_token, recover_token_exp, recover_selector, attempt_count, last_attempt, last_login, metadata, created_at, updated_at, deleted_at, totp_secret, totp_secret_backup, sms_phone_number, recovery_codes
`

type CreateUserParams struct {
	ID          string  `json:"id"`
	Email       string  `json:"email"`
	Password    string  `json:"password"`
	Username    *string `json:"username"`
	Confirmed   *int64  `json:"confirmed"`
	FirstName   *string `json:"first_name"`
	LastName    *string `json:"last_name"`
	DisplayName *string `json:"display_name"`
	Phone       *string `json:"phone"`
	Location    *string `json:"location"`
	Metadata    *string `json:"metadata"`
	CreatedAt   string  `json:"created_at"`
	UpdatedAt   string  `json:"updated_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (AuthUser, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.Password,
		arg.Username,
		arg.Confirmed,
		arg.FirstName,
		arg.LastName,
		arg.DisplayName,
		arg.Phone,
		arg.Location,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AuthUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Username,
		&i.Confirmed,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.Phone,
		&i.Location,
		&i.ConfirmToken,
		&i.ConfirmSelector,
		&i.RecoverToken,
		&i.RecoverTokenExp,
		&i.RecoverSelector,
		&i.AttemptCount,
		&i.LastAttempt,
		&i.LastLogin,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TotpSecret,
		&i.TotpSecretBackup,
		&i.SmsPhoneNumber,
		&i.RecoveryCodes,
	)
	return i, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_keys WHERE id = ?
`

func (q *Queries) DeleteAPIKey(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteAPIKey, id)
	return err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
DELETE FROM auth_tokens WHERE expires_at < ? OR revoked_at IS NOT NULL
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context, expiresAt apptime.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredTokens, expiresAt)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM auth_tokens WHERE id = ?
`

func (q *Queries) DeleteToken(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteToken, id)
	return err
}

const getAPIKeyByHash = `-- name: GetAPIKeyByHash :one
SELECT id, user_id, name, key_prefix, key_hash, scopes, expires_at, last_used_at, last_used_ip, revoked_at, created_at, updated_at FROM api_keys WHERE key_hash = ? AND revoked_at IS NULL LIMIT 1
`

func (q *Queries) GetAPIKeyByHash(ctx context.Context, keyHash string) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByHash, keyHash)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyPrefix,
		&i.KeyHash,
		&i.Scopes,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT id, user_id, name, key_prefix, key_hash, scopes, expires_at, last_used_at, last_used_ip, revoked_at, created_at, updated_at FROM api_keys WHERE id = ? AND revoked_at IS NULL LIMIT 1
`

func (q *Queries) GetAPIKeyByID(ctx context.Context, id string) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByID, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyPrefix,
		&i.KeyHash,
		&i.Scopes,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAPIKeyByPrefix = `-- name: GetAPIKeyByPrefix :one
SELECT id, user_id, name, key_prefix, key_hash, scopes, expires_at, last_used_at, last_used_ip, revoked_at, created_at, updated_at FROM api_keys WHERE key_prefix = ? AND revoked_at IS NULL LIMIT 1
`

func (q *Queries) GetAPIKeyByPrefix(ctx context.Context, keyPrefix string) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByPrefix, keyPrefix)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyPrefix,
		&i.KeyHash,
		&i.Scopes,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.LastUsedIp,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTokenByHash = `-- name: GetTokenByHash :one
SELECT id, user_id, token_hash, token, type, family_id, provider, provider_uid, access_token, oauth_expiry, expires_at, used_at, revoked_at, created_at, device_info, ip_address FROM auth_tokens WHERE token_hash = ? AND revoked_at IS NULL LIMIT 1
`

func (q *Queries) GetTokenByHash(ctx context.Context, tokenHash *string) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, getTokenByHash, tokenHash)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Token,
		&i.Type,
		&i.FamilyID,
		&i.Provider,
		&i.ProviderUid,
		&i.AccessToken,
		&i.OauthExpiry,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.DeviceInfo,
		&i.IpAddress,
	)
	return i, err
}

const getTokenByID = `-- name: GetTokenByID :one
SELECT id, user_id, token_hash, token, type, family_id, provider, provider_uid, access_token, oauth_expiry, expires_at, used_at, revoked_at, created_at, device_info, ip_address FROM auth_tokens WHERE id = ? LIMIT 1
`

func (q *Queries) GetTokenByID(ctx context.Context, id string) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, getTokenByID, id)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Token,
		&i.Type,
		&i.FamilyID,
		&i.Provider,
		&i.ProviderUid,
		&i.AccessToken,
		&i.OauthExpiry,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.DeviceInfo,
		&i.IpAddress,
	)
	return i, err
}

const getTokenByProviderUID = `-- name: GetTokenByProviderUID :one
SELECT id, user_id, token_hash, token, type, family_id, provider, provider_uid, access_token, oauth_expiry, expires_at, used_at, revoked_at, created_at, device_info, ip_address FROM auth_tokens WHERE provider_uid = ? AND provider = ? AND revoked_at IS NULL LIMIT 1
`

type GetTokenByProviderUIDParams struct {
	ProviderUid *string `json:"provider_uid"`
	Provider    *string `json:"provider"`
}

func (q *Queries) GetTokenByProviderUID(ctx context.Context, arg GetTokenByProviderUIDParams) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, getTokenByProviderUID, arg.ProviderUid, arg.Provider)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Token,
		&i.Type,
		&i.FamilyID,
		&i.Provider,
		&i.ProviderUid,
		&i.AccessToken,
		&i.OauthExpiry,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.DeviceInfo,
		&i.IpAddress,
	)
	return i, err
}

const getTokenByToken = `-- name: GetTokenByToken :one
SELECT id, user_id, token_hash, token, type, family_id, provider, provider_uid, access_token, oauth_expiry, expires_at, used_at, revoked_at, created_at, device_info, ip_address FROM auth_tokens WHERE token = ? AND revoked_at IS NULL LIMIT 1
`

func (q *Queries) GetTokenByToken(ctx context.Context, token *string) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, getTokenByToken, token)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.Token,
		&i.Type,
		&i.FamilyID,
		&i.Provider,
		&i.ProviderUid,
		&i.AccessToken,
		&i.OauthExpiry,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.RevokedAt,
		&i.CreatedAt,
		&i.DeviceInfo,
		&i.IpAddress,
	)
	return i, err
}

const getUserByConfirmSelector = `-- name: GetUserByConfirmSelector :one
SELECT id, email, password, username, confirmed, first_name, last_name, display_name, phone, location, confirm_token, confirm_selector, recover_token, recover_token_exp, recover_selector, attempt_count, last_attempt, last_login, metadata, created_at, updated_at, deleted_at, totp_secret, totp_secret_backup, sms_phone_number, recovery_codes FROM auth_users WHERE confirm_selector = ? AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserByConfirmSelector(ctx context.Context, confirmSelector *string) (AuthUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByConfirmSelector, confirmSelector)
	var i AuthUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Username,
		&i.Confirmed,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.Phone,
		&i.Location,
		&i.ConfirmToken,
		&i.ConfirmSelector,
		&i.RecoverToken,
		&i.RecoverTokenExp,
		&i.RecoverSelector,
		&i.AttemptCount,
		&i.LastAttempt,
		&i.LastLogin,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TotpSecret,
		&i.TotpSecretBackup,
		&i.SmsPhoneNumber,
		&i.RecoveryCodes,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password, username, confirmed, first_name, last_name, display_name, phone, location, confirm_token, confirm_selector, recover_token, recover_token_exp, recover_selector, attempt_count, last_attempt, last_login, metadata, created_at, updated_at, deleted_at, totp_secret, totp_secret_backup, sms_phone_number, recovery_codes FROM auth_users WHERE email = ? AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (AuthUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i AuthUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Username,
		&i.Confirmed,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.Phone,
		&i.Location,
		&i.ConfirmToken,
		&i.ConfirmSelector,
		&i.RecoverToken,
		&i.RecoverTokenExp,
		&i.RecoverSelector,
		&i.AttemptCount,
		&i.LastAttempt,
		&i.LastLogin,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TotpSecret,
		&i.TotpSecretBackup,
		&i.SmsPhoneNumber,
		&i.RecoveryCodes,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password, username, confirmed, first_name, last_name, display_name, phone, location, confirm_token, confirm_selector, recover_token, recover_token_exp, recover_selector, attempt_count, last_attempt, last_login, metadata, created_at, updated_at, deleted_at, totp_secret, totp_secret_backup, sms_phone_number, recovery_codes FROM auth_users WHERE id = ? AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (AuthUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i AuthUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Username,
		&i.Confirmed,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.Phone,
		&i.Location,
		&i.ConfirmToken,
		&i.ConfirmSelector,
		&i.RecoverToken,
		&i.RecoverTokenExp,
		&i.RecoverSelector,
		&i.AttemptCount,
		&i.LastAttempt,
		&i.LastLogin,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TotpSecret,
		&i.TotpSecretBackup,
		&i.SmsPhoneNumber,
		&i.RecoveryCodes,
	)
	return i, err
}

const getUserByRecoverSelector = `-- name: GetUserByRecoverSelector :one
SELECT id, email, password, username, confirmed, first_name, last_name, display_name, phone, location, confirm_token, confirm_selector, recover_token, recover_token_exp, recover_selector, attempt_count, last_attempt, last_login, metadata, created_at, updated_at, deleted_at, totp_secret, totp_secret_backup, sms_phone_number, recovery_codes FROM auth_users WHERE recover_selector = ? AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserByRecoverSelector(ctx context.Context, recoverSelector *string) (AuthUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByRecoverSelector, recoverSelector)
	var i AuthUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Username,
		&i.Confirmed,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.Phone,
		&i.Location,
		&i.ConfirmToken,
		&i.ConfirmSelector,
		&i.RecoverToken,
		&i.RecoverTokenExp,
		&i.RecoverSelector,
		&i.AttemptCount,
		&i.LastAttempt,
		&i.LastLogin,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TotpSecret,
		&i.TotpSecretBackup,
		&i.SmsPhoneNumber,
		&i.RecoveryCodes,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, email, password, username, confirmed, first_name, last_name, display_name, phone, location, confirm_token, confirm_selector, recover_token, recover_token_exp, recover_selector, attempt_count, last_attempt, last_login, metadata, created_at, updated_at, deleted_at, totp_secret, totp_secret_backup, sms_phone_number, recovery_codes FROM auth_users WHERE username = ? AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username *string) (AuthUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i AuthUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Username,
		&i.Confirmed,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.Phone,
		&i.Location,
		&i.ConfirmToken,
		&i.ConfirmSelector,
		&i.RecoverToken,
		&i.RecoverTokenExp,
		&i.RecoverSelector,
		&i.AttemptCount,
		&i.LastAttempt,
		&i.LastLogin,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TotpSecret,
		&i.TotpSecretBackup,
		&i.SmsPhoneNumber,
		&i.RecoveryCodes,
	)
	return i, err
}

const hardDeleteUser = `-- name: HardDeleteUser :exec
DELETE FROM auth_users WHERE id = ?
`

func (q *Queries) HardDeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, hardDeleteUser, id)
	return err
}

const listAPIKeysByUserID = `-- name: ListAPIKeysByUserID :many
SELECT id, user_id, name, key_prefix, key_hash, scopes, expires_at, last_used_at, last_used_ip, revoked_at, created_at, updated_at FROM api_keys WHERE user_id = ? AND revoked_at IS NULL ORDER BY created_at DESC
`

func (q *Queries) ListAPIKeysByUserID(ctx context.Context, userID string) ([]ApiKey, error) {
	rows, err := q.db.QueryContext(ctx, listAPIKeysByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.KeyPrefix,
			&i.KeyHash,
			&i.Scopes,
			&i.ExpiresAt,
			&i.LastUsedAt,
			&i.LastUsedIp,
			&i.RevokedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokensByFamily = `-- name: ListTokensByFamily :many
SELECT id, user_id, token_hash, token, type, family_id, provider, provider_uid, access_token, oauth_expiry, expires_at, used_at, revoked_at, created_at, device_info, ip_address FROM auth_tokens WHERE family_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListTokensByFamily(ctx context.Context, familyID *string) ([]AuthToken, error) {
	rows, err := q.db.QueryContext(ctx, listTokensByFamily, familyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuthToken{}
	for rows.Next() {
		var i AuthToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.Token,
			&i.Type,
			&i.FamilyID,
			&i.Provider,
			&i.ProviderUid,
			&i.AccessToken,
			&i.OauthExpiry,
			&i.ExpiresAt,
			&i.UsedAt,
			&i.RevokedAt,
			&i.CreatedAt,
			&i.DeviceInfo,
			&i.IpAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokensByUserID = `-- name: ListTokensByUserID :many
SELECT id, user_id, token_hash, token, type, family_id, provider, provider_uid, access_token, oauth_expiry, expires_at, used_at, revoked_at, created_at, device_info, ip_address FROM auth_tokens WHERE user_id = ? AND revoked_at IS NULL ORDER BY created_at DESC
`

func (q *Queries) ListTokensByUserID(ctx context.Context, userID string) ([]AuthToken, error) {
	rows, err := q.db.QueryContext(ctx, listTokensByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuthToken{}
	for rows.Next() {
		var i AuthToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.Token,
			&i.Type,
			&i.FamilyID,
			&i.Provider,
			&i.ProviderUid,
			&i.AccessToken,
			&i.OauthExpiry,
			&i.ExpiresAt,
			&i.UsedAt,
			&i.RevokedAt,
			&i.CreatedAt,
			&i.DeviceInfo,
			&i.IpAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, password, username, confirmed, first_name, last_name, display_name, phone, location, confirm_token, confirm_selector, recover_token, recover_token_exp, recover_selector, attempt_count, last_attempt, last_login, metadata, created_at, updated_at, deleted_at, totp_secret, totp_secret_backup, sms_phone_number, recovery_codes FROM auth_users WHERE deleted_at IS NULL ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListUsersParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]AuthUser, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuthUser{}
	for rows.Next() {
		var i AuthUser
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Password,
			&i.Username,
			&i.Confirmed,
			&i.FirstName,
			&i.LastName,
			&i.DisplayName,
			&i.Phone,
			&i.Location,
			&i.ConfirmToken,
			&i.ConfirmSelector,
			&i.RecoverToken,
			&i.RecoverTokenExp,
			&i.RecoverSelector,
			&i.AttemptCount,
			&i.LastAttempt,
			&i.LastLogin,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotpSecret,
			&i.TotpSecretBackup,
			&i.SmsPhoneNumber,
			&i.RecoveryCodes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAPIKey = `-- name: RevokeAPIKey :exec
UPDATE api_keys SET revoked_at = ?, updated_at = ? WHERE id = ?
`

type RevokeAPIKeyParams struct {
	RevokedAt apptime.NullTime `json:"revoked_at"`
	UpdatedAt string           `json:"updated_at"`
	ID        string           `json:"id"`
}

func (q *Queries) RevokeAPIKey(ctx context.Context, arg RevokeAPIKeyParams) error {
	_, err := q.db.ExecContext(ctx, revokeAPIKey, arg.RevokedAt, arg.UpdatedAt, arg.ID)
	return err
}

const revokeAPIKeysByUserID = `-- name: RevokeAPIKeysByUserID :exec
UPDATE api_keys SET revoked_at = ?, updated_at = ? WHERE user_id = ? AND revoked_at IS NULL
`

type RevokeAPIKeysByUserIDParams struct {
	RevokedAt apptime.NullTime `json:"revoked_at"`
	UpdatedAt string           `json:"updated_at"`
	UserID    string           `json:"user_id"`
}

func (q *Queries) RevokeAPIKeysByUserID(ctx context.Context, arg RevokeAPIKeysByUserIDParams) error {
	_, err := q.db.ExecContext(ctx, revokeAPIKeysByUserID, arg.RevokedAt, arg.UpdatedAt, arg.UserID)
	return err
}

const revokeToken = `-- name: RevokeToken :exec
UPDATE auth_tokens SET revoked_at = ? WHERE id = ?
`

type RevokeTokenParams struct {
	RevokedAt apptime.NullTime `json:"revoked_at"`
	ID        string           `json:"id"`
}

func (q *Queries) RevokeToken(ctx context.Context, arg RevokeTokenParams) error {
	_, err := q.db.ExecContext(ctx, revokeToken, arg.RevokedAt, arg.ID)
	return err
}

const revokeTokensByFamily = `-- name: RevokeTokensByFamily :exec
UPDATE auth_tokens SET revoked_at = ? WHERE family_id = ? AND revoked_at IS NULL
`

type RevokeTokensByFamilyParams struct {
	RevokedAt apptime.NullTime `json:"revoked_at"`
	FamilyID  *string          `json:"family_id"`
}

func (q *Queries) RevokeTokensByFamily(ctx context.Context, arg RevokeTokensByFamilyParams) error {
	_, err := q.db.ExecContext(ctx, revokeTokensByFamily, arg.RevokedAt, arg.FamilyID)
	return err
}

const revokeTokensByType = `-- name: RevokeTokensByType :exec
UPDATE auth_tokens SET revoked_at = ? WHERE user_id = ? AND type = ? AND revoked_at IS NULL
`

type RevokeTokensByTypeParams struct {
	RevokedAt apptime.NullTime `json:"revoked_at"`
	UserID    string           `json:"user_id"`
	Type      string           `json:"type"`
}

func (q *Queries) RevokeTokensByType(ctx context.Context, arg RevokeTokensByTypeParams) error {
	_, err := q.db.ExecContext(ctx, revokeTokensByType, arg.RevokedAt, arg.UserID, arg.Type)
	return err
}

const revokeTokensByUserID = `-- name: RevokeTokensByUserID :exec
UPDATE auth_tokens SET revoked_at = ? WHERE user_id = ? AND revoked_at IS NULL
`

type RevokeTokensByUserIDParams struct {
	RevokedAt apptime.NullTime `json:"revoked_at"`
	UserID    string           `json:"user_id"`
}

func (q *Queries) RevokeTokensByUserID(ctx context.Context, arg RevokeTokensByUserIDParams) error {
	_, err := q.db.ExecContext(ctx, revokeTokensByUserID, arg.RevokedAt, arg.UserID)
	return err
}

const setUserConfirmToken = `-- name: SetUserConfirmToken :exec
UPDATE auth_users SET
    confirm_token = ?,
    confirm_selector = ?,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type SetUserConfirmTokenParams struct {
	ConfirmToken    *string `json:"confirm_token"`
	ConfirmSelector *string `json:"confirm_selector"`
	UpdatedAt       string  `json:"updated_at"`
	ID              string  `json:"id"`
}

func (q *Queries) SetUserConfirmToken(ctx context.Context, arg SetUserConfirmTokenParams) error {
	_, err := q.db.ExecContext(ctx, setUserConfirmToken,
		arg.ConfirmToken,
		arg.ConfirmSelector,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const setUserRecoverToken = `-- name: SetUserRecoverToken :exec
UPDATE auth_users SET
    recover_token = ?,
    recover_selector = ?,
    recover_token_exp = ?,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type SetUserRecoverTokenParams struct {
	RecoverToken    *string          `json:"recover_token"`
	RecoverSelector *string          `json:"recover_selector"`
	RecoverTokenExp apptime.NullTime `json:"recover_token_exp"`
	UpdatedAt       string           `json:"updated_at"`
	ID              string           `json:"id"`
}

func (q *Queries) SetUserRecoverToken(ctx context.Context, arg SetUserRecoverTokenParams) error {
	_, err := q.db.ExecContext(ctx, setUserRecoverToken,
		arg.RecoverToken,
		arg.RecoverSelector,
		arg.RecoverTokenExp,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const setUserSMSPhone = `-- name: SetUserSMSPhone :exec
UPDATE auth_users SET
    sms_phone_number = ?,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type SetUserSMSPhoneParams struct {
	SmsPhoneNumber *string `json:"sms_phone_number"`
	UpdatedAt      string  `json:"updated_at"`
	ID             string  `json:"id"`
}

func (q *Queries) SetUserSMSPhone(ctx context.Context, arg SetUserSMSPhoneParams) error {
	_, err := q.db.ExecContext(ctx, setUserSMSPhone, arg.SmsPhoneNumber, arg.UpdatedAt, arg.ID)
	return err
}

const setUserTOTP = `-- name: SetUserTOTP :exec
UPDATE auth_users SET
    totp_secret = ?,
    totp_secret_backup = ?,
    recovery_codes = ?,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type SetUserTOTPParams struct {
	TotpSecret       *string `json:"totp_secret"`
	TotpSecretBackup *string `json:"totp_secret_backup"`
	RecoveryCodes    *string `json:"recovery_codes"`
	UpdatedAt        string  `json:"updated_at"`
	ID               string  `json:"id"`
}

func (q *Queries) SetUserTOTP(ctx context.Context, arg SetUserTOTPParams) error {
	_, err := q.db.ExecContext(ctx, setUserTOTP,
		arg.TotpSecret,
		arg.TotpSecretBackup,
		arg.RecoveryCodes,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE auth_users SET deleted_at = ?, updated_at = ? WHERE id = ?
`

type SoftDeleteUserParams struct {
	DeletedAt apptime.NullTime `json:"deleted_at"`
	UpdatedAt string           `json:"updated_at"`
	ID        string           `json:"id"`
}

func (q *Queries) SoftDeleteUser(ctx context.Context, arg SoftDeleteUserParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteUser, arg.DeletedAt, arg.UpdatedAt, arg.ID)
	return err
}

const updateAPIKey = `-- name: UpdateAPIKey :exec
UPDATE api_keys SET name = ?, scopes = ?, expires_at = ?, updated_at = ? WHERE id = ?
`

type UpdateAPIKeyParams struct {
	Name      string           `json:"name"`
	Scopes    json.RawMessage  `json:"scopes"`
	ExpiresAt apptime.NullTime `json:"expires_at"`
	UpdatedAt string           `json:"updated_at"`
	ID        string           `json:"id"`
}

func (q *Queries) UpdateAPIKey(ctx context.Context, arg UpdateAPIKeyParams) error {
	_, err := q.db.ExecContext(ctx, updateAPIKey,
		arg.Name,
		arg.Scopes,
		arg.ExpiresAt,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys SET last_used_at = ?, last_used_ip = ?, updated_at = ? WHERE id = ?
`

type UpdateAPIKeyLastUsedParams struct {
	LastUsedAt apptime.NullTime `json:"last_used_at"`
	LastUsedIp *string          `json:"last_used_ip"`
	UpdatedAt  string           `json:"updated_at"`
	ID         string           `json:"id"`
}

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, arg UpdateAPIKeyLastUsedParams) error {
	_, err := q.db.ExecContext(ctx, updateAPIKeyLastUsed,
		arg.LastUsedAt,
		arg.LastUsedIp,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateTokenUsed = `-- name: UpdateTokenUsed :exec
UPDATE auth_tokens SET used_at = ? WHERE id = ?
`

type UpdateTokenUsedParams struct {
	UsedAt apptime.NullTime `json:"used_at"`
	ID     string           `json:"id"`
}

func (q *Queries) UpdateTokenUsed(ctx context.Context, arg UpdateTokenUsedParams) error {
	_, err := q.db.ExecContext(ctx, updateTokenUsed, arg.UsedAt, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE auth_users SET
    email = ?,
    password = ?,
    username = ?,
    confirmed = ?,
    first_name = ?,
    last_name = ?,
    display_name = ?,
    phone = ?,
    location = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type UpdateUserParams struct {
	Email       string  `json:"email"`
	Password    string  `json:"password"`
	Username    *string `json:"username"`
	Confirmed   *int64  `json:"confirmed"`
	FirstName   *string `json:"first_name"`
	LastName    *string `json:"last_name"`
	DisplayName *string `json:"display_name"`
	Phone       *string `json:"phone"`
	Location    *string `json:"location"`
	Metadata    *string `json:"metadata"`
	UpdatedAt   string  `json:"updated_at"`
	ID          string  `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Email,
		arg.Password,
		arg.Username,
		arg.Confirmed,
		arg.FirstName,
		arg.LastName,
		arg.DisplayName,
		arg.Phone,
		arg.Location,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateUserConfirmation = `-- name: UpdateUserConfirmation :exec
UPDATE auth_users SET
    confirmed = ?,
    confirm_token = NULL,
    confirm_selector = NULL,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type UpdateUserConfirmationParams struct {
	Confirmed *int64 `json:"confirmed"`
	UpdatedAt string `json:"updated_at"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateUserConfirmation(ctx context.Context, arg UpdateUserConfirmationParams) error {
	_, err := q.db.ExecContext(ctx, updateUserConfirmation, arg.Confirmed, arg.UpdatedAt, arg.ID)
	return err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE auth_users SET
    last_login = ?,
    attempt_count = 0,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type UpdateUserLastLoginParams struct {
	LastLogin apptime.NullTime `json:"last_login"`
	UpdatedAt string           `json:"updated_at"`
	ID        string           `json:"id"`
}

func (q *Queries) UpdateUserLastLogin(ctx context.Context, arg UpdateUserLastLoginParams) error {
	_, err := q.db.ExecContext(ctx, updateUserLastLogin, arg.LastLogin, arg.UpdatedAt, arg.ID)
	return err
}

const updateUserLoginAttempt = `-- name: UpdateUserLoginAttempt :exec
UPDATE auth_users SET
    attempt_count = ?,
    last_attempt = ?,
    updated_at = ?
WHERE id = ? AND deleted_at IS NULL
`

type UpdateUserLoginAttemptParams struct {
	AttemptCount *int64           `json:"attempt_count"`
	LastAttempt  apptime.NullTime `json:"last_attempt"`
	UpdatedAt    string           `json:"updated_at"`
	ID           string           `json:"id"`
}

func (q *Queries) UpdateUserLoginAttempt(ctx context.Context, arg UpdateUserLoginAttemptParams) error {
	_, err := q.db.ExecContext(ctx, updateUserLoginAttempt,
		arg.AttemptCount,
		arg.LastAttempt,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE auth_users SET password = ?, updated_at = ? WHERE id = ? AND deleted_at IS NULL
`

type UpdateUserPasswordParams struct {
	Password  string `json:"password"`
	UpdatedAt string `json:"updated_at"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.Password, arg.UpdatedAt, arg.ID)
	return err
}
